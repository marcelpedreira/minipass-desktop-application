.TH "MbusMasterFunctions" 3 "29 Jan 2010" "Version Library version 2.6" "FieldTalk Modbus Master C++ Library" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MbusMasterFunctions \- 
.PP
Base class which implements Modbus data and control functions.  

.SH SYNOPSIS
.br
.PP
.PP
Inherited by \fBMbusSerialMasterProtocol\fP, and \fBMbusTcpMasterProtocol\fP.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual \fB~MbusMasterFunctions\fP ()"
.br
.RI "\fIDestructor. \fP"
.ti -1c
.RI "virtual int \fBisOpen\fP ()=0"
.br
.RI "\fIReturns whether the protocol is open or not. \fP"
.ti -1c
.RI "virtual void \fBcloseProtocol\fP ()=0"
.br
.RI "\fICloses an open protocol including any associated communication resources (com ports or sockets). \fP"
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBMbusMasterFunctions\fP ()"
.br
.RI "\fIConstructs a \fBMbusMasterFunctions\fP object and initialises its data. \fP"
.in -1c
.SS "Bit Access"
Table 0:00000 (Coils) and Table 1:0000 (Input Status) 
.in +1c
.ti -1c
.RI "int \fBreadCoils\fP (int slaveAddr, int startRef, int bitArr[], int refCnt)"
.br
.RI "\fIModbus function 1, Read Coil Status/Read Coils. \fP"
.ti -1c
.RI "int \fBreadInputDiscretes\fP (int slaveAddr, int startRef, int bitArr[], int refCnt)"
.br
.RI "\fIModbus function 2, Read Inputs Status/Read Input Discretes. \fP"
.ti -1c
.RI "int \fBwriteCoil\fP (int slaveAddr, int bitAddr, int bitVal)"
.br
.RI "\fIModbus function 5, Force Single Coil/Write Coil. \fP"
.ti -1c
.RI "int \fBforceMultipleCoils\fP (int slaveAddr, int startRef, const int bitArr[], int refCnt)"
.br
.RI "\fIModbus function 15 (0F Hex), Force Multiple Coils. \fP"
.in -1c
.SS "16-bit Access"
Table 4:00000 (Holding Registers) and Table 3:00000 (Input Registers) 
.in +1c
.ti -1c
.RI "int \fBreadMultipleRegisters\fP (int slaveAddr, int startRef, short regArr[], int refCnt)"
.br
.RI "\fIModbus function 3, Read Holding Registers/Read Multiple Registers. \fP"
.ti -1c
.RI "int \fBreadInputRegisters\fP (int slaveAddr, int startRef, short regArr[], int refCnt)"
.br
.RI "\fIModbus function 4, Read Input Registers. \fP"
.ti -1c
.RI "int \fBwriteSingleRegister\fP (int slaveAddr, int regAddr, short regVal)"
.br
.RI "\fIModbus function 6, Preset Single Register/Write Single Register. \fP"
.ti -1c
.RI "int \fBwriteMultipleRegisters\fP (int slaveAddr, int startRef, const short regArr[], int refCnt)"
.br
.RI "\fIModbus function 16 (10 Hex), Preset Multiple Registers/Write Multiple Registers. \fP"
.ti -1c
.RI "int \fBmaskWriteRegister\fP (int slaveAddr, int regAddr, short andMask, short orMask)"
.br
.RI "\fIModbus function 22 (16 Hex), Mask Write Register. \fP"
.ti -1c
.RI "int \fBreadWriteRegisters\fP (int slaveAddr, int readRef, short readArr[], int readCnt, int writeRef, const short writeArr[], int writeCnt)"
.br
.RI "\fIModbus function 23 (17 Hex), Read/Write Registers. \fP"
.in -1c
.SS "32-bit Access"
Table 4:00000 (Holding Registers) and Table 3:00000 (Input Registers) 
.in +1c
.ti -1c
.RI "int \fBreadMultipleLongInts\fP (int slaveAddr, int startRef, long int32Arr[], int refCnt)"
.br
.RI "\fIModbus function 3 for 32-bit long int data types, Read Holding Registers/Read Multiple Registers as long int data. \fP"
.ti -1c
.RI "int \fBreadInputLongInts\fP (int slaveAddr, int startRef, long int32Arr[], int refCnt)"
.br
.RI "\fIModbus function 4 for 32-bit long int data types, Read Input Registers as long int data. \fP"
.ti -1c
.RI "int \fBwriteMultipleLongInts\fP (int slaveAddr, int startRef, const long int32Arr[], int refCnt)"
.br
.RI "\fIModbus function 16 (10 Hex) for 32-bit long int data types, Preset Multiple Registers/Write Multiple Registers with long int data. \fP"
.ti -1c
.RI "int \fBreadMultipleFloats\fP (int slaveAddr, int startRef, float float32Arr[], int refCnt)"
.br
.RI "\fIModbus function 3 for 32-bit float data types, Read Holding Registers/Read Multiple Registers as float data. \fP"
.ti -1c
.RI "int \fBreadInputFloats\fP (int slaveAddr, int startRef, float float32Arr[], int refCnt)"
.br
.RI "\fIModbus function 4 for 32-bit float data types, Read Input Registers as float data. \fP"
.ti -1c
.RI "int \fBwriteMultipleFloats\fP (int slaveAddr, int startRef, const float float32Arr[], int refCnt)"
.br
.RI "\fIModbus function 16 (10 Hex) for 32-bit float data types, Preset Multiple Registers/Write Multiple Registers with float data. \fP"
.ti -1c
.RI "int \fBreadMultipleMod10000\fP (int slaveAddr, int startRef, long int32Arr[], int refCnt)"
.br
.RI "\fIModbus function 3 for 32-bit modulo-10000 long int data types, Read Holding Registers/Read Multiple Registers as modulo-10000 long int data. \fP"
.ti -1c
.RI "int \fBreadInputMod10000\fP (int slaveAddr, int startRef, long int32Arr[], int refCnt)"
.br
.RI "\fIModbus function 4 for 32-bit modulo-10000 long int data types, Read Input Registers as modulo-10000 long int data. \fP"
.ti -1c
.RI "int \fBwriteMultipleMod10000\fP (int slaveAddr, int startRef, const long int32Arr[], int refCnt)"
.br
.RI "\fIModbus function 16 (10 Hex) for 32-bit modulo-10000 long int data types, Preset Multiple Registers/Write Multiple Registers with modulo-10000 long int data. \fP"
.in -1c
.SS "Diagnostics"
 
.in +1c
.ti -1c
.RI "int \fBreadExceptionStatus\fP (int slaveAddr, unsigned char *statusBytePtr)"
.br
.RI "\fIModbus function 7, Read Exception Status. \fP"
.ti -1c
.RI "int \fBreturnQueryData\fP (int slaveAddr, const unsigned char queryArr[], unsigned char echoArr[], int len)"
.br
.RI "\fIModbus function code 8, sub-function 00, Return Query Data. \fP"
.ti -1c
.RI "int \fBrestartCommunicationsOption\fP (int slaveAddr, int clearEventLog)"
.br
.RI "\fIModbus function code 8, sub-function 01, Restart Communications Option. \fP"
.in -1c
.SS "Custom Function Codes"
 
.in +1c
.ti -1c
.RI "int \fBcustomFunction\fP (int slaveAddr, int functionCode, void *requestData, size_t requestLen, void *responseData, size_t *responseLenPtr)"
.br
.RI "\fIUser Defined Function Code
.PP
This method can be used to implement User Defined Function Codes. \fP"
.in -1c
.SS "Protocol Configuration"
 
.in +1c
.ti -1c
.RI "int \fBsetTimeout\fP (int timeOut)"
.br
.RI "\fIConfigures time-out. \fP"
.ti -1c
.RI "int \fBgetTimeout\fP ()"
.br
.RI "\fIReturns the time-out value. \fP"
.ti -1c
.RI "int \fBsetPollDelay\fP (int pollDelay)"
.br
.RI "\fIConfigures poll delay. \fP"
.ti -1c
.RI "int \fBgetPollDelay\fP ()"
.br
.RI "\fIReturns the poll delay time. \fP"
.ti -1c
.RI "int \fBsetRetryCnt\fP (int retryCnt)"
.br
.RI "\fIConfigures the automatic retry setting. \fP"
.ti -1c
.RI "int \fBgetRetryCnt\fP ()"
.br
.RI "\fIReturns the automatic retry count. \fP"
.in -1c
.SS "Transmission Statistic Functions"
 
.in +1c
.ti -1c
.RI "long \fBgetTotalCounter\fP ()"
.br
.RI "\fIReturns how often a message transfer has been executed. \fP"
.ti -1c
.RI "void \fBresetTotalCounter\fP ()"
.br
.RI "\fIResets total message transfer counter. \fP"
.ti -1c
.RI "long \fBgetSuccessCounter\fP ()"
.br
.RI "\fIReturns how often a message transfer was successful. \fP"
.ti -1c
.RI "void \fBresetSuccessCounter\fP ()"
.br
.RI "\fIResets successful message transfer counter. \fP"
.in -1c
.SS "Slave Configuration"
 
.in +1c
.ti -1c
.RI "void \fBconfigureBigEndianInts\fP ()"
.br
.RI "\fIConfigures 32-bit int data type functions to do a word swap. \fP"
.ti -1c
.RI "void \fBconfigureLittleEndianInts\fP ()"
.br
.RI "\fIConfigures 32-bit int data type functions not to do a word swap. \fP"
.ti -1c
.RI "void \fBconfigureIeeeFloats\fP ()"
.br
.RI "\fIConfigures float data type functions not to do a word swap. \fP"
.ti -1c
.RI "void \fBconfigureSwappedFloats\fP ()"
.br
.RI "\fIConfigures float data type functions to do a word swap. \fP"
.ti -1c
.RI "void \fBconfigureStandard32BitMode\fP ()"
.br
.RI "\fIConfigures all slaves for Standard 32-bit Mode. \fP"
.ti -1c
.RI "void \fBconfigureEnron32BitMode\fP ()"
.br
.RI "\fIConfigures all slaves for Daniel/ENRON 32-bit Mode. \fP"
.ti -1c
.RI "void \fBconfigureCountFromOne\fP ()"
.br
.RI "\fIConfigures the reference counting scheme to start with one for all slaves. \fP"
.ti -1c
.RI "void \fBconfigureCountFromZero\fP ()"
.br
.RI "\fIConfigures the reference counting scheme to start with zero for all slaves. \fP"
.ti -1c
.RI "int \fBconfigureBigEndianInts\fP (int slaveAddr)"
.br
.RI "\fIEnables int data type functions to do a word swap on a per slave basis. \fP"
.ti -1c
.RI "int \fBconfigureLittleEndianInts\fP (int slaveAddr)"
.br
.RI "\fIDisables word swapping for int data type functions on a per slave basis. \fP"
.ti -1c
.RI "int \fBconfigureIeeeFloats\fP (int slaveAddr)"
.br
.RI "\fIDisables float data type functions to do a word swap on a per slave basis. \fP"
.ti -1c
.RI "int \fBconfigureSwappedFloats\fP (int slaveAddr)"
.br
.RI "\fIEnables float data type functions to do a word swap on a per slave basis. \fP"
.ti -1c
.RI "int \fBconfigureStandard32BitMode\fP (int slaveAddr)"
.br
.RI "\fIConfigures a slave for Standard 32-bit Register Mode. \fP"
.ti -1c
.RI "int \fBconfigureEnron32BitMode\fP (int slaveAddr)"
.br
.RI "\fIConfigures all slaves for Daniel/ENRON 32-bit Mode. \fP"
.ti -1c
.RI "int \fBconfigureCountFromOne\fP (int slaveAddr)"
.br
.RI "\fIConfigures a slave's reference counting scheme to start with one. \fP"
.ti -1c
.RI "int \fBconfigureCountFromZero\fP (int slaveAddr)"
.br
.RI "\fIConfigures a slave's reference counting scheme to start with zero. \fP"
.in -1c
.SS "Utility Functions"
 
.in +1c
.ti -1c
.RI "static TCHAR * \fBgetPackageVersion\fP ()"
.br
.RI "\fIReturns the library version number. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Base class which implements Modbus data and control functions. 

The functions provided by this base class apply to all protocol flavours via inheritance. For a more detailed description see section \fBData and Control Functions for all Modbus Protocol Flavours\fP.
.PP
\fBSee also:\fP
.RS 4
\fBData and Control Functions for all Modbus Protocol Flavours\fP 
.PP
\fBMbusSerialMasterProtocol\fP, \fBMbusRtuMasterProtocol\fP 
.PP
\fBMbusAsciiMasterProtocol\fP, \fBMbusTcpMasterProtocol\fP, \fBMbusRtuOverTcpMasterProtocol\fP 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBMbusMasterFunctions\fP ()\fC [protected]\fP"
.PP
Constructs a \fBMbusMasterFunctions\fP object and initialises its data. It also detects the endianess of the machine it's running on and configures byte swapping if necessary. 
.SS "~\fBMbusMasterFunctions\fP ()\fC [virtual]\fP"
.PP
Destructor. Does clean-up and closes an open protocol including any associated communication resources (serial ports or sockets). 
.SH "Member Function Documentation"
.PP 
.SS "int readCoils (int slaveAddr, int startRef, int bitArr[], int refCnt)"
.PP
Modbus function 1, Read Coil Status/Read Coils. Reads the contents of the discrete outputs (coils, 0:00000 table).
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 1 - 255) 
.br
\fIstartRef\fP Start reference (Range: 1 - 65536) 
.br
\fIbitArr\fP Buffer which will contain the data read 
.br
\fIrefCnt\fP Number of coils to be read (Range: 1-2000) 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success or error code. See \fBError Management\fP for a list of error codes. 
.RE
.PP
\fBNote:\fP
.RS 4
No broadcast supported 
.RE
.PP

.SS "int readInputDiscretes (int slaveAddr, int startRef, int bitArr[], int refCnt)"
.PP
Modbus function 2, Read Inputs Status/Read Input Discretes. Reads the contents of the discrete inputs (input status, 1:00000 table).
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 1 - 255) 
.br
\fIstartRef\fP Start reference (Range: 1 - 65536) 
.br
\fIbitArr\fP Buffer which will contain the data read 
.br
\fIrefCnt\fP Number of coils to be read (Range: 1-2000) 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success or error code. See \fBError Management\fP for a list of error codes. 
.RE
.PP
\fBNote:\fP
.RS 4
No broadcast supported 
.RE
.PP

.SS "int writeCoil (int slaveAddr, int bitAddr, int bitVal)"
.PP
Modbus function 5, Force Single Coil/Write Coil. Sets a single discrete output variable (coil, 0:00000 table) to either ON or OFF.
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 0 - 255) 
.br
\fIbitAddr\fP Coil address (Range: 1 - 65536) 
.br
\fIbitVal\fP true sets, false clears discrete output variable 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success or error code. See \fBError Management\fP for a list of error codes. 
.RE
.PP
\fBNote:\fP
.RS 4
Broadcast supported for serial protocols 
.RE
.PP

.SS "int forceMultipleCoils (int slaveAddr, int startRef, const int bitArr[], int refCnt)"
.PP
Modbus function 15 (0F Hex), Force Multiple Coils. Writes binary values into a sequence of discrete outputs (coils, 0:00000 table).
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 1 - 255) 
.br
\fIstartRef\fP Start reference (Range: 1 - 65536) 
.br
\fIbitArr\fP Buffer which contains the data to be sent 
.br
\fIrefCnt\fP Number of coils to be written (Range: 1-1968) 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success or error code. See \fBError Management\fP for a list of error codes. 
.RE
.PP
\fBNote:\fP
.RS 4
Broadcast supported for serial protocols 
.RE
.PP

.SS "int readMultipleRegisters (int slaveAddr, int startRef, short regArr[], int refCnt)"
.PP
Modbus function 3, Read Holding Registers/Read Multiple Registers. Reads the contents of the output registers (holding registers, 4:00000 table).
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 1 - 255) 
.br
\fIstartRef\fP Start register (Range: 1 - 65536) 
.br
\fIregArr\fP Buffer which will be filled with the data read 
.br
\fIrefCnt\fP Number of registers to be read (Range: 1-125) 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success or error code. See \fBError Management\fP for a list of error codes. 
.RE
.PP
\fBNote:\fP
.RS 4
No broadcast supported 
.RE
.PP

.SS "int readInputRegisters (int slaveAddr, int startRef, short regArr[], int refCnt)"
.PP
Modbus function 4, Read Input Registers. Read the contents of the input registers (3:00000 table).
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 1 - 255) 
.br
\fIstartRef\fP Start register (Range: 1 - 65536) 
.br
\fIregArr\fP Buffer which will be filled with the data read. 
.br
\fIrefCnt\fP Number of registers to be read (Range: 1-125) 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success or error code. See \fBError Management\fP for a list of error codes. 
.RE
.PP
\fBNote:\fP
.RS 4
No broadcast supported 
.RE
.PP

.SS "int writeSingleRegister (int slaveAddr, int regAddr, short regVal)"
.PP
Modbus function 6, Preset Single Register/Write Single Register. Writes a value into a single output register (holding register, 4:00000 reference).
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 0 - 255) 
.br
\fIregAddr\fP Register address (Range: 1 - 65536) 
.br
\fIregVal\fP Data to be sent 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success or error code. See \fBError Management\fP for a list of error codes. 
.RE
.PP
\fBNote:\fP
.RS 4
Broadcast supported for serial protocols 
.RE
.PP

.SS "int writeMultipleRegisters (int slaveAddr, int startRef, const short regArr[], int refCnt)"
.PP
Modbus function 16 (10 Hex), Preset Multiple Registers/Write Multiple Registers. Writes values into a sequence of output registers (holding registers, 4:00000 table).
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 0 - 255) 
.br
\fIstartRef\fP Start register (Range: 1 - 65536) 
.br
\fIregArr\fP Buffer with the data to be sent. 
.br
\fIrefCnt\fP Number of registers to be written (Range: 1-123) 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success or error code. See \fBError Management\fP for a list of error codes. 
.RE
.PP
\fBNote:\fP
.RS 4
Broadcast supported for serial protocols 
.RE
.PP

.SS "int maskWriteRegister (int slaveAddr, int regAddr, short andMask, short orMask)"
.PP
Modbus function 22 (16 Hex), Mask Write Register. Masks bits according to an AND & an OR mask into a single output register (holding register, 4:00000 reference). Masking is done as follows: result = (currentVal AND andMask) OR (orMask AND (NOT andMask))
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 1 - 255) 
.br
\fIregAddr\fP Register address (Range: 1 - 65536) 
.br
\fIandMask\fP Mask to be applied as a logic AND to the register 
.br
\fIorMask\fP Mask to be applied as a logic OR to the register 
.RE
.PP
\fBNote:\fP
.RS 4
No broadcast supported 
.RE
.PP

.SS "int readWriteRegisters (int slaveAddr, int readRef, short readArr[], int readCnt, int writeRef, const short writeArr[], int writeCnt)"
.PP
Modbus function 23 (17 Hex), Read/Write Registers. Combines reading and writing of the output registers in one transaction (holding registers, 4:00000 table).
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 1 - 255) 
.br
\fIreadRef\fP Start register for reading (Range: 1 - 65536) 
.br
\fIreadArr\fP Buffer which will contain the data read 
.br
\fIreadCnt\fP Number of registers to be read (Range: 1-125) 
.br
\fIwriteRef\fP Start register for writing (Range: 1 - 65536) 
.br
\fIwriteArr\fP Buffer with data to be sent 
.br
\fIwriteCnt\fP Number of registers to be written (Range: 1-121) 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success or error code. See \fBError Management\fP for a list of error codes. 
.RE
.PP
\fBNote:\fP
.RS 4
No broadcast supported 
.RE
.PP

.SS "int readMultipleLongInts (int slaveAddr, int startRef, long int32Arr[], int refCnt)"
.PP
Modbus function 3 for 32-bit long int data types, Read Holding Registers/Read Multiple Registers as long int data. Reads the contents of pairs of consecutive output registers (holding registers, 4:00000 table) into 32-bit long int values.
.PP
\fBRemarks:\fP
.RS 4
Depending on the 32-bit Mode setting, an int will be transferred as two consecutive 16-bit registers (Standard) or as one 32-bit register (Daniel/Enron). 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 1 - 255) 
.br
\fIstartRef\fP Start reference (Range: 1 - 65536) 
.br
\fIint32Arr\fP Buffer which will be filled with the data read 
.br
\fIrefCnt\fP Number of long integers to be read (Range: 1-62) 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success or error code. See \fBError Management\fP for a list of error codes. 
.RE
.PP
\fBNote:\fP
.RS 4
No broadcast supported 
.RE
.PP

.SS "int readInputLongInts (int slaveAddr, int startRef, long int32Arr[], int refCnt)"
.PP
Modbus function 4 for 32-bit long int data types, Read Input Registers as long int data. Reads the contents of pairs of consecutive input registers (3:00000 table) into 32-bit long int values.
.PP
\fBRemarks:\fP
.RS 4
Depending on the 32-bit Mode setting, an int will be transferred as two consecutive 16-bit registers (Standard) or as one 32-bit register (Daniel/Enron). 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 1 - 255) 
.br
\fIstartRef\fP Start reference (Range: 1 - 65536) 
.br
\fIint32Arr\fP Buffer which will be filled with the data read 
.br
\fIrefCnt\fP Number of long integers to be read (Range: 1-62) 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success or error code. See \fBError Management\fP for a list of error codes. 
.RE
.PP
\fBNote:\fP
.RS 4
No broadcast supported 
.RE
.PP

.SS "int writeMultipleLongInts (int slaveAddr, int startRef, const long int32Arr[], int refCnt)"
.PP
Modbus function 16 (10 Hex) for 32-bit long int data types, Preset Multiple Registers/Write Multiple Registers with long int data. Writes long int values into pairs of output registers (holding registers, 4:00000 table).
.PP
\fBRemarks:\fP
.RS 4
Depending on the 32-bit Mode setting, an int will be transferred as two consecutive 16-bit registers (Standard) or as one 32-bit register (Daniel/Enron). 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 0 - 255) 
.br
\fIstartRef\fP Start reference (Range: 1 - 65536) 
.br
\fIint32Arr\fP Buffer with the data to be sent 
.br
\fIrefCnt\fP Number of long integers to be sent (Range: 1-61) 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success or error code. See \fBError Management\fP for a list of error codes. 
.RE
.PP
\fBNote:\fP
.RS 4
Broadcast supported for serial protocols 
.RE
.PP

.SS "int readMultipleFloats (int slaveAddr, int startRef, float float32Arr[], int refCnt)"
.PP
Modbus function 3 for 32-bit float data types, Read Holding Registers/Read Multiple Registers as float data. Reads the contents of pairs of consecutive output registers (holding registers, 4:00000 table) into float values.
.PP
\fBRemarks:\fP
.RS 4
Depending on the 32-bit Mode setting, an int will be transferred as two consecutive 16-bit registers (Standard) or as one 32-bit register (Daniel/Enron). 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 1 - 255) 
.br
\fIstartRef\fP Start reference (Range: 1 - 65536) 
.br
\fIfloat32Arr\fP Buffer which will be filled with the data read 
.br
\fIrefCnt\fP Number of float values to be read (Range: 1-62) 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success or error code. See \fBError Management\fP for a list of error codes. 
.RE
.PP
\fBNote:\fP
.RS 4
No broadcast supported 
.RE
.PP

.SS "int readInputFloats (int slaveAddr, int startRef, float float32Arr[], int refCnt)"
.PP
Modbus function 4 for 32-bit float data types, Read Input Registers as float data. Reads the contents of pairs of consecutive input registers (3:00000 table) into float values.
.PP
\fBRemarks:\fP
.RS 4
Depending on the 32-bit Mode setting, an int will be transferred as two consecutive 16-bit registers (Standard) or as one 32-bit register (Daniel/Enron). 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 1 - 255) 
.br
\fIstartRef\fP Start reference (Range: 1 - 65536) 
.br
\fIfloat32Arr\fP Buffer which will be filled with the data read 
.br
\fIrefCnt\fP Number of floats to be read (Range: 1-62) 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success or error code. See \fBError Management\fP for a list of error codes. 
.RE
.PP
\fBNote:\fP
.RS 4
No broadcast supported 
.RE
.PP

.SS "int writeMultipleFloats (int slaveAddr, int startRef, const float float32Arr[], int refCnt)"
.PP
Modbus function 16 (10 Hex) for 32-bit float data types, Preset Multiple Registers/Write Multiple Registers with float data. Writes float values into pairs of output registers (holding registers, 4:00000 table).
.PP
\fBRemarks:\fP
.RS 4
Depending on the 32-bit Mode setting, an int will be transferred as two consecutive 16-bit registers (Standard) or as one 32-bit register (Daniel/Enron). 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 0 - 255) 
.br
\fIstartRef\fP Start reference (Range: 1 - 65536) 
.br
\fIfloat32Arr\fP Buffer with the data to be sent 
.br
\fIrefCnt\fP Number of float values to be sent (Range: 1-61) 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success or error code. See \fBError Management\fP for a list of error codes. 
.RE
.PP
\fBNote:\fP
.RS 4
Broadcast supported for serial protocols 
.RE
.PP

.SS "int readMultipleMod10000 (int slaveAddr, int startRef, long int32Arr[], int refCnt)"
.PP
Modbus function 3 for 32-bit modulo-10000 long int data types, Read Holding Registers/Read Multiple Registers as modulo-10000 long int data. Reads the contents of pairs of consecutive output registers (holding registers, 4:00000 table) representing a modulo-10000 long int value into 32-bit int values and performs number format conversion.
.PP
\fBRemarks:\fP
.RS 4
Depending on the 32-bit Mode setting, an int will be transferred as two consecutive 16-bit registers (Standard) or as one 32-bit register (Daniel/Enron). 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 1 - 255) 
.br
\fIstartRef\fP Start reference (Range: 1 - 65536) 
.br
\fIint32Arr\fP Buffer which will be filled with the data read 
.br
\fIrefCnt\fP Number of M10K integers to be read (Range: 1-62) 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success or error code. See \fBError Management\fP for a list of error codes. 
.RE
.PP
\fBNote:\fP
.RS 4
No broadcast supported 
.RE
.PP

.SS "int readInputMod10000 (int slaveAddr, int startRef, long int32Arr[], int refCnt)"
.PP
Modbus function 4 for 32-bit modulo-10000 long int data types, Read Input Registers as modulo-10000 long int data. Reads the contents of pairs of consecutive input registers (3:00000 table) representing a modulo-10000 long int value into 32-bit long int values and performs number format conversion.
.PP
\fBRemarks:\fP
.RS 4
Depending on the 32-bit Mode setting, an int will be transferred as two consecutive 16-bit registers (Standard) or as one 32-bit register (Daniel/Enron). 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 1 - 255) 
.br
\fIstartRef\fP Start reference (Range: 1 - 65536) 
.br
\fIint32Arr\fP Buffer which will be filled with the data read 
.br
\fIrefCnt\fP Number of M10K integers to be read (Range: 1-62) 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success or error code. See \fBError Management\fP for a list of error codes. 
.RE
.PP
\fBNote:\fP
.RS 4
No broadcast supported 
.RE
.PP

.SS "int writeMultipleMod10000 (int slaveAddr, int startRef, const long int32Arr[], int refCnt)"
.PP
Modbus function 16 (10 Hex) for 32-bit modulo-10000 long int data types, Preset Multiple Registers/Write Multiple Registers with modulo-10000 long int data. Writes long int values into pairs of output registers (holding registers, 4:00000 table) representing a modulo-10000 long int value and performs number format conversion.
.PP
\fBRemarks:\fP
.RS 4
Depending on the 32-bit Mode setting, an int will be transferred as two consecutive 16-bit registers (Standard) or as one 32-bit register (Daniel/Enron). 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 0 - 255) 
.br
\fIstartRef\fP Start reference (Range: 1 - 65536) 
.br
\fIint32Arr\fP Buffer with the data to be sent 
.br
\fIrefCnt\fP Number of long integer values to be sent (Range: 1-61) 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success or error code. See \fBError Management\fP for a list of error codes. 
.RE
.PP
\fBNote:\fP
.RS 4
Broadcast supported for serial protocols 
.RE
.PP

.SS "int readExceptionStatus (int slaveAddr, unsigned char * statusBytePtr)"
.PP
Modbus function 7, Read Exception Status. Reads the eight exception status coils within the slave device.
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 1 - 255) 
.br
\fIstatusBytePtr\fP Slave status byte. The meaning of this status byte is slave specific and varies from device to device. 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success or error code. See \fBError Management\fP for a list of error codes. 
.RE
.PP
\fBNote:\fP
.RS 4
No broadcast supported 
.RE
.PP

.SS "int returnQueryData (int slaveAddr, const unsigned char queryArr[], unsigned char echoArr[], int len)"
.PP
Modbus function code 8, sub-function 00, Return Query Data. \fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 1 - 255) 
.br
\fIqueryArr\fP Buffer with data to be sent 
.br
\fIechoArr\fP Buffer which will contain the data read 
.br
\fIlen\fP Number of bytes send sent and read back 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success, FTALK_INVALID_REPLY_ERROR if reply does not match query data or error code. See \fBError Management\fP for a list of error codes. 
.RE
.PP
\fBNote:\fP
.RS 4
No broadcast supported 
.RE
.PP

.SS "int restartCommunicationsOption (int slaveAddr, int clearEventLog)"
.PP
Modbus function code 8, sub-function 01, Restart Communications Option. \fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 1 - 255) 
.br
\fIclearEventLog\fP Flag when set to one clears in addition the slave's communication even log. 
.RE
.PP
\fBReturns:\fP
.RS 4
FTALK_SUCCESS on success. See \fBError Management\fP for a list of error codes. 
.RE
.PP
\fBNote:\fP
.RS 4
No broadcast supported 
.RE
.PP

.SS "int setTimeout (int msTime)"
.PP
Configures time-out. This function sets the operation or socket time-out to the specified value.
.PP
\fBRemarks:\fP
.RS 4
The time-out value is indicative only and not guaranteed to be maintained. How precise it is followed depends on the operating system used, it's scheduling priority and it's system timer resolution. 
.RE
.PP
\fBNote:\fP
.RS 4
A protocol must be closed in order to configure it. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fImsTime\fP Timeout value in ms (Range: 1 - 100000) 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIFTALK_SUCCESS\fP Success 
.br
\fIFTALK_ILLEGAL_ARGUMENT_ERROR\fP Argument out of range 
.br
\fIFTALK_ILLEGAL_STATE_ERROR\fP Protocol is already open 
.RE
.PP

.SS "int getTimeout ()\fC [inline]\fP"
.PP
Returns the time-out value. \fBRemarks:\fP
.RS 4
The time-out value is indicative only and not guaranteed to be maintained. How precise it is followed depends on the operating system used, it's scheduling priority and it's system timer resolution. 
.RE
.PP
\fBReturns:\fP
.RS 4
Timeout value in ms 
.RE
.PP

.SS "int setPollDelay (int msTime)"
.PP
Configures poll delay. This function sets the delay time which applies between two consecutive Modbus read/write. A value of 0 disables the poll delay.
.PP
\fBRemarks:\fP
.RS 4
The delay value is indicative only and not guaranteed to be maintained. How precise it is followed depends on the operating system used, it's scheduling priority and it's system timer resolution. 
.RE
.PP
\fBNote:\fP
.RS 4
A protocol must be closed in order to configure it. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fImsTime\fP Delay time in ms (Range: 0 - 100000), 0 disables poll delay 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIFTALK_SUCCESS\fP Success 
.br
\fIFTALK_ILLEGAL_ARGUMENT_ERROR\fP Argument out of range 
.br
\fIFTALK_ILLEGAL_STATE_ERROR\fP Protocol is already open 
.RE
.PP

.SS "int getPollDelay ()\fC [inline]\fP"
.PP
Returns the poll delay time. \fBReturns:\fP
.RS 4
Delay time in ms, 0 if poll delay is switched off 
.RE
.PP

.SS "int setRetryCnt (int retries)"
.PP
Configures the automatic retry setting. A value of 0 disables any automatic retries. 
.PP
\fBNote:\fP
.RS 4
A protocol must be closed in order to configure it.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIretries\fP Retry count (Range: 0 - 10), 0 disables retries 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIFTALK_SUCCESS\fP Success 
.br
\fIFTALK_ILLEGAL_ARGUMENT_ERROR\fP Argument out of range 
.br
\fIFTALK_ILLEGAL_STATE_ERROR\fP Protocol is already open 
.RE
.PP

.SS "int getRetryCnt ()\fC [inline]\fP"
.PP
Returns the automatic retry count. \fBReturns:\fP
.RS 4
Retry count 
.RE
.PP

.SS "long getTotalCounter ()\fC [inline]\fP"
.PP
Returns how often a message transfer has been executed. \fBReturns:\fP
.RS 4
Counter value 
.RE
.PP

.SS "long getSuccessCounter ()\fC [inline]\fP"
.PP
Returns how often a message transfer was successful. \fBReturns:\fP
.RS 4
Counter value 
.RE
.PP

.SS "void configureBigEndianInts ()"
.PP
Configures 32-bit int data type functions to do a word swap. Modbus is using little-endian word order for 32-bit values. The data transfer functions operating upon 32-bit int data types can be configured to do a word swap which enables them to read 32-bit data correctly from a big-endian slave. 
.SS "void configureLittleEndianInts ()"
.PP
Configures 32-bit int data type functions not to do a word swap. This is the default. 
.SS "void configureIeeeFloats ()"
.PP
Configures float data type functions not to do a word swap. This is the default. 
.SS "void configureSwappedFloats ()"
.PP
Configures float data type functions to do a word swap. The data functions operating upon 32-bit float data types can be configured to do a word swap. 
.PP
\fBNote:\fP
.RS 4
Most platforms store floats in IEEE 754 little-endian order which does not need a word swap. 
.RE
.PP

.SS "void configureStandard32BitMode ()"
.PP
Configures all slaves for Standard 32-bit Mode. In Standard 32-bit Register Mode a 32-bit value is transmitted as two consecutive 16-bit Modbus registers.
.PP
\fBRemarks:\fP
.RS 4
This is the default mode 
.RE
.PP

.SS "void configureEnron32BitMode ()"
.PP
Configures all slaves for Daniel/ENRON 32-bit Mode. Some Modbus flavours like the Daniel/Enron protocol represent a 32-bit value using one 32-bit Modbus register instead of two 16-bit registers. 
.SS "void configureCountFromOne ()"
.PP
Configures the reference counting scheme to start with one for all slaves. This renders the reference range to be 1 to 0x10000 and register #0 is an illegal register.
.PP
\fBRemarks:\fP
.RS 4
This is the default mode 
.RE
.PP

.SS "void configureCountFromZero ()"
.PP
Configures the reference counting scheme to start with zero for all slaves. This renders the valid reference range to be 0 to 0xFFFF.
.PP
This renders the first register to be #0 for all slaves. 
.SS "int configureBigEndianInts (int slaveAddr)"
.PP
Enables int data type functions to do a word swap on a per slave basis. Modbus is using little-endian word order for 32-bit values. The data transfer functions operating upon 32-bit int data types can be configured to do a word swap which enables them to read 32-bit data correctly from a big-endian machine.
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 1 - 255). A value of zero configures the behaviour for broadcasting. 
.RE
.PP

.SS "int configureLittleEndianInts (int slaveAddr)"
.PP
Disables word swapping for int data type functions on a per slave basis. Modbus is using little-endian word order for 32-bit values. This setting assumes that the slave also serves 32-bit data in little little-endian word order.
.PP
\fBRemarks:\fP
.RS 4
This is the default mode
.RE
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 1 - 255). A value of zero configures the behaviour for broadcasting. 
.RE
.PP

.SS "int configureIeeeFloats (int slaveAddr)"
.PP
Disables float data type functions to do a word swap on a per slave basis. Modbus is using little-endian word order for 32-bit values. This setting assumes that the slave also serves 32-bit floats in little little-endian word order which is the most common case.
.PP
\fBRemarks:\fP
.RS 4
This is the default mode
.RE
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 1 - 255). A value of zero configures the behaviour for broadcasting. 
.RE
.PP

.SS "int configureSwappedFloats (int slaveAddr)"
.PP
Enables float data type functions to do a word swap on a per slave basis. The data functions operating upon 32-bit float data types can be configured to do a word swap. 
.PP
\fBNote:\fP
.RS 4
Most platforms store floats in IEEE 754 little-endian order which does not need a word swap.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 1 - 255). A value of zero configures the behaviour for broadcasting. 
.RE
.PP

.SS "int configureStandard32BitMode (int slaveAddr)"
.PP
Configures a slave for Standard 32-bit Register Mode. In Standard 32-bit Register Mode a 32-bit value is transmitted as two consecutive 16-bit Modbus registers.
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 1 - 255). A value of zero configures the behaviour for broadcasting. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIFTALK_SUCCESS\fP Success 
.br
\fIFTALK_ILLEGAL_ARGUMENT_ERROR\fP Argument out of range
.RE
.PP
\fBRemarks:\fP
.RS 4
This is the default mode 
.RE
.PP
\fBNote:\fP
.RS 4
This function call also re-configures the endianess to default little-endian for 32-bit values! 
.RE
.PP

.SS "int configureEnron32BitMode (int slaveAddr)"
.PP
Configures all slaves for Daniel/ENRON 32-bit Mode. Some Modbus flavours like the Daniel/Enron protocol represent a 32-bit value using one 32-bit Modbus register instead of two 16-bit registers.
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 1 - 255). A value of zero configures the behaviour for broadcasting. 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIFTALK_SUCCESS\fP Success 
.br
\fIFTALK_ILLEGAL_ARGUMENT_ERROR\fP Argument out of range 
.RE
.PP
\fBNote:\fP
.RS 4
This function call also re-configures the endianess to big-endian for 32-bit values as defined by the Daniel/ENRON protocol! 
.RE
.PP

.SS "int configureCountFromOne (int slaveAddr)"
.PP
Configures a slave's reference counting scheme to start with one. This renders the reference range to be 1 to 0x10000 and register #0 is an illegal register.
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 1 - 255). A value of zero configures the behaviour for broadcasting.
.RE
.PP
\fBRemarks:\fP
.RS 4
This is the default mode 
.RE
.PP

.SS "int configureCountFromZero (int slaveAddr)"
.PP
Configures a slave's reference counting scheme to start with zero. This is also known as PDU addressing.
.PP
This renders the valid reference range to be 0 to 0xFFFF.
.PP
\fBParameters:\fP
.RS 4
\fIslaveAddr\fP Modbus address of slave device or unit identifier (Range: 1 - 255). A value of zero configures the behaviour for broadcasting. 
.RE
.PP

.SS "virtual int isOpen ()\fC [pure virtual]\fP"
.PP
Returns whether the protocol is open or not. \fBReturn values:\fP
.RS 4
\fItrue\fP = open 
.br
\fIfalse\fP = closed 
.RE
.PP

.PP
Implemented in \fBMbusTcpMasterProtocol\fP, and \fBMbusSerialMasterProtocol\fP.
.SS "TCHAR * getPackageVersion ()\fC [static]\fP"
.PP
Returns the library version number. \fBReturns:\fP
.RS 4
Library version string 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for FieldTalk Modbus Master C++ Library from the source code.
